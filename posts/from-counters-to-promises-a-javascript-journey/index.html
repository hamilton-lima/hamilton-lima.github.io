<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><title>From counters to promises a javascript journey - Hamilton Lima</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=https://hamiltonlima.comfavicon.png><link rel=canonical href=https://hamiltonlima.com/posts/from-counters-to-promises-a-javascript-journey/><link rel=stylesheet href=/css/style.min.381fd69187be1f5dde5031ac9014016e77965dbc38358cb065b6fede27b5861c.css><link rel=stylesheet href=/assets/css/extended.min.9729f28a5087b689b946e103d96abd63bfd37b1417effa251dbf798312e3fba5.css><meta property="og:title" content="From counters to promises a javascript journey"><meta property="og:type" content="website"><meta property="og:url" content="https://hamiltonlima.com/posts/from-counters-to-promises-a-javascript-journey/"><meta name=twitter:card content="summary"><meta name=twitter:site content="@athanazio"><meta name=twitter:creator content="@athanazio"><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel=stylesheet></head><body class="page frame page-blog-single"><div id=menu-main-mobile class=menu-main-mobile><ul class=menu><li class=menu-item-posts><a href=https://hamiltonlima.com/posts>Posts</a></li></ul></div><div id=wrapper class=wrapper><div class=header><a class=header-logo href=/>Hamilton Lima</a><div class=menu-main><ul><li class=menu-item-posts><a href=/posts><span>Posts</span></a></li></ul></div><div id=toggle-menu-main-mobile class=hamburger-trigger><button class=hamburger>Menu</button></div></div><div class=blog><div class=intro><h1>From counters to promises a javascript journey<span class=dot>.</span></h1></div><div class=content><blockquote><p>Beauty always promises, but never gives anything. <a href=https://en.wikipedia.org/wiki/Simone_Weil>Simone Weil</a></p></blockquote><p>Unlike beauty, javascript promises are faithful, and will be fulfilled&mldr; unless someone rejects it :) If you ever need to load images using javascript or did anything that needs to wait until something is done, you probably used a promise, maybe even without noticing. I see Promises as a nice way to simplify the <a href=http://callbackhell.com>callback hell</a>, but don&rsquo;t be fooled, the callbacks are still there, they are only organized in a more simpler way. Let´s take a look at a simple example that loads one image. consider that &ldquo;foo&rdquo; variable is a canvas where we draw something in memory and we want to show that as an image.</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>var promise = new Promise(function(resolve, reject) {   
    var image = new Image();
    image.onload = function() {
        resolve(image);
    }
    image.src = foo.toDataURL(&#34;image/png&#34;);
});
...
promise.then(function(data){
    myGreatImage = data;
});
</code></pre></div><p>The code above says: &ldquo;When I&rsquo;m done loading the image you can have it&rdquo;. the resolve function from the promise is calling the then implementation, don&rsquo;t tell anybody but there is a callback here&mldr; :) but with a nice name and a very readable structure.</p><h2 id=promises-on-robolucha-masks>Promises on robolucha masks</h2><p>During this weekend I finally add promises to the mask implementation of robolucha. The original implementation was handling image loading by counting the number of images loaded and with a ready method, but after the image loading the tint of the images and the mask building itself wasn&rsquo;t controlling the asynchronous nature of the operation, as a result of it, in Chrome it was working but at Firefox wasn&rsquo;t. The table below describes the features from the robolucha mask builder and the asynchronous challenges from each one.</p><table><thead><tr><th>Feature</th><th>Implementation</th><th>Challenge</th></tr></thead><tbody><tr><td>Base image loading</td><td>Add onload to each image and control the number of images loaded to track if the set of images are ready to be used</td><td>Wait for all the images to load</td></tr><tr><td>Mask building</td><td>Draw tinted images on a canvas and return the base64 image data as src of the resulting image</td><td>Wait for all layers to tint and after it wait for the mask to draw</td></tr><tr><td>Tint an image layer</td><td>Paint the black layer pixels with the chosen color</td><td>Wait for the layer to tint</td></tr></tbody></table><p>The great challenge was at the mask building where the code needed to wait for several promises to resolve and after that return a promise, so this is the implementation of the mask build.</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>this.build = function(width, height, data) {
	
	var imagePromises = new Array();
	
	for (var i = 0; i &lt; data.length; i++) {
	    var layer = this.layers\[data\[i\].name\]; 
	    if (layer) {
		var rgb = this.hexToRgb(data\[i\].color);
		imagePromises.push(this.tint(this.findImageByName(data\[i\].name, data\[i\].element), 
                     rgb.red, rgb.green,rgb.blue));
	    }
	}
	
	var resultPromise = new Promise(function(resolve, reject) {
	    Promise.all(imagePromises).then(function(images) {
		var resultCanvas = document.createElement(&#34;canvas&#34;);
		resultCanvas.width = width;
		resultCanvas.height = height;
		var ctx = resultCanvas.getContext(&#39;2d&#39;);
		ctx.imageSmoothingEnabled = true;
		
		for (var i = 0; i &lt; data.length; i++) {
		    ctx.drawImage(images\[i\], 0, 0, width, height);
		}
		
		// return the base64 string of the image
		resolve(resultCanvas.toDataURL(&#34;image/png&#34;));
	    });
	});
	
	return resultPromise;
    }

</code></pre></div><p>Let&rsquo;s talk about some important steps on this code:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>imagePromises.push(this.tint(...
</code></pre></div><p>The &ldquo;tint&rdquo; function returns a promise that will be resolved when the image painting is done. We add to the list of promises that we are waiting for.</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>var resultPromise = new Promise(function(resolve, reject) {
	    Promise.all(imagePromises).then(function(images) {...
</code></pre></div><p>The &ldquo;Promise.all&rdquo; function allow us to wait for a list of promises and do something at the &ldquo;then&rdquo; function, however, the parameter received at the function is the list of data each promise sends from &ldquo;resolve&rdquo; function. <img src=/images/2017/02/promises-image-to-promisse.all_.jpg alt> With &ldquo;Promise.all&rdquo; I was able to solve one problem that was wait for several other promises, but now I had another one how to transform the result list in one result that should be a &ldquo;promise&rdquo; result? The solution I found was to create a new promise with &ldquo;Promise.all&rdquo; inside so the resolve function would be available.</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>resolve(resultCanvas.toDataURL(&#34;image/png&#34;));
</code></pre></div><p>This resolve function is from the new promise, so when the &ldquo;then&rdquo; implementation of the &ldquo;Promise.all&rdquo; finished it will resolve this new promise sending the image as base64. If you know any other way around this, please let me know :)</p></div></div><div class=footer><div class=footer-social><span class="social-icon social-icon-twitter"><a href=https://twitter.com/athanazio title=twitter target=_blank rel=noopener><img src=/images/icons/twitter.svg width=24 height=24 alt=twitter></a></span>
<span class="social-icon social-icon-github"><a href=https://github.com/hamilton-lima title=github target=_blank rel=noopener><img src=/images/icons/github.svg width=24 height=24 alt=github></a></span>
<span class="social-icon social-icon-linkedin"><a href=https://www.linkedin.com/in/hamiltonlima title=linkedin target=_blank rel=noopener><img src=/images/icons/linkedin.svg width=24 height=24 alt=linkedin></a></span></div></div></div><script type=text/javascript src=/js/bundle.min.df8701b5f509374aa1fd6b7f39e6100d9eedbb268d023d3bec1a6e8220fd6dee.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-CFNGHJCTX3"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','G-CFNGHJCTX3');</script></body></html>