<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><title>Using Redis Publish and Subscribe - Hamilton Lima</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=https://hamiltonlima.comfavicon.png><link rel=canonical href=https://hamiltonlima.com/posts/using-redis-publish-and-subscribe/><link rel=stylesheet href=/css/style.min.341d362bef2b6b1437e0cefb99a0cb7e4141b6954f8398c1b10275f699edc362.css><link rel=stylesheet href=/assets/css/extended.min.9729f28a5087b689b946e103d96abd63bfd37b1417effa251dbf798312e3fba5.css><meta property="og:title" content="Using Redis Publish and Subscribe"><meta property="og:type" content="website"><meta property="og:url" content="https://hamiltonlima.com/posts/using-redis-publish-and-subscribe/"><meta name=twitter:card content="summary"><meta name=twitter:site content="@zerostaticio"><meta name=twitter:creator content="@zerostaticio"><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&amp;display=swap" rel=stylesheet></head><body class='page frame page-blog-single'><div id=menu-main-mobile class=menu-main-mobile><ul class=menu><li class=menu-item-posts><a href=https://hamiltonlima.com/posts>Posts</a></li></ul></div><div id=wrapper class=wrapper><div class=header><a class=header-logo href=/>Hamilton Lima</a><div class=menu-main><ul><li class=menu-item-posts><a href=/posts><span>Posts</span></a></li></ul></div><div id=toggle-menu-main-mobile class=hamburger-trigger><button class=hamburger>Menu</button></div></div><div class=blog><div class=intro><h1>Using Redis Publish and Subscribe<span class=dot>.</span></h1></div><div class=content><p>There is this game called Robolucha where you code your robots to fight in a virtual arena. I&rsquo;ve been working on this project for some years and last year decided to rewrite everything, mainly for the sake of technical exploration and this post share challenges using Redis Publish and subscribe.</p><h2 id=proving-the-concept>Proving the concept</h2><p>Before I start to hit the keyboard to refactor MatchStatePublisher to send match states to Redis, I had some homework to do. So I build a POC (Proof of concept) to understand how <a href=https://github.com/xetorthio/jedis>Jedis</a> client works and is possible to do with it. The first discovery is that you can&rsquo;t use the same connection for publishing AND subscribing, you need to separate JedisPool or even a Jedis connection if there is no pool. The POC has two separated apps one to publish data and another to subscribe to the changes, the code can be found <a href=https://github.com/hamilton-lima/robolucha/tree/master/pocs/redis/java-pubsub>here</a></p><h2 id=how-to-test-it>How to test it</h2><p>1. start the Redis server using the default <a href=https://hub.docker.com/_/redis/>Redis docker image</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>docker run --name test-redis --rm -p 6379:6379 -d redis
</span></span></code></pre></div><p>2. run the Subscriber class 3. run the Publisher class that will start 10 threads to send 5000 messages each The subscriber screen should display every single message received.</p><h2 id=using-the-lessons-in-the-runner-application>Using the lessons in the runner application</h2><p>After the POC establish the foundations for the implementation I add some extra requirements:</p><ul><li>The queue names should be auto-generated based on the class name</li><li>Observables from <a href=https://github.com/ReactiveX/RxJava>RxJava</a> should be used to implement the subscription</li><li>The subscription process should not block the current Thread</li><li>The queue message parsing from and to objects should be transparent</li><li>Publishing should accept <a href=https://en.wikipedia.org/wiki/Plain_old_Java_object>POJO</a> as parameters</li><li>The entire publish and subscribe process should be testable</li></ul><p>I can say that all the requirements were fulfilled. Some with more challenges than others :) Let&rsquo;s go over the details of each one.</p><h2 id=queue-names-generation-observables-and-asynchronous-subscription>Queue names generation, Observables, and asynchronous subscription</h2><p>The method that generates the queue name is very straightforward</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>private String getChannelName(Class clazz) {
</span></span><span class=line><span class=cl>    return clazz.getCanonicalName();
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>So when using subscribe or publish the queue names would be something like com.robolucha.models.Luchador For the use of Observables, the method subscribes returns a <a href=http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/subjects/BehaviorSubject.html>BehaviorSubject</a> of whatever class is sent as a parameter for the subscription.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>public &lt;T&gt; BehaviorSubject subscribe(Class&lt;T&gt; clazzToSubscribe) {
</span></span><span class=line><span class=cl>    BehaviorSubject&lt;T&gt; result = BehaviorSubject.create();
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    return result;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p><a href=https://github.com/xetorthio/jedis>Jedis</a> client is implementation blocks the current thread when the subscription happens, to workaround that there is a separated Thread to subscribe and an additional listener to interrupt this thread the BehaviorSubject completes.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Thread subscriber = new Thread(new Runnable() {
</span></span><span class=line><span class=cl>    public void run() {
</span></span><span class=line><span class=cl>        Jedis subscriber = subscriberPool.getResource();
</span></span><span class=line><span class=cl>        subscriber.subscribe(new JedisPubSub() {
</span></span><span class=line><span class=cl>        ...
</span></span><span class=line><span class=cl>        }, channel);
</span></span><span class=line><span class=cl>        subscriber.close();
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>});
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>result.subscribe(new ThreadKiller&lt;&gt;(subscriber));
</span></span><span class=line><span class=cl>subscriber.start();
</span></span></code></pre></div><h2 id=transparent-parsing-pojo>Transparent parsing, POJO</h2><p>When publishing the object is converted to JSON and when receiving the message the JSON string is converted to the expected object type as well. making the process transparent for the consumer of the RemoteQueue implementation.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>public void onMessage(String channel, String message) { (1)
</span></span><span class=line><span class=cl>    T data = gson.fromJson(message, clazzToSubscribe); (2)
</span></span><span class=line><span class=cl>    result.onNext(data); (3)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>(1) happens when the subscription receives a message from the queue (2) convert the JSON to the object type defined by clazzToSubscribe (3) push the received value to the BehaviourSubject stream</p><h2 id=unit-testing-er-end-to-end-testing>Unit testing&mldr; er&mldr; End to End testing</h2><p>The initial expectation was to build a unit test, but the final implementation is actually and End2End, and actually, a Redis server is used in the test. To have the Redis server running for the test the class <a href=https://github.com/hamilton-lima/robolucha/blob/master/src/runner/src-test/com/robolucha/publisher/RedisDockerHelper.java>RedisDockerHelper</a> was created to wrap the docker commands to start and stop a Redis server, meaning that in the test the usage is only .start() and .stop(), see class <a href=https://github.com/hamilton-lima/robolucha/blob/master/src/runner/src-test/com/robolucha/publisher/RedisDockerHelper.java>RedisDockerHelper</a> that run the docker commands and logs the console outputs. Here are some fragments from the test</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>try (RemoteQueue queue = new RemoteQueue(Config.getInstance())) {
</span></span></code></pre></div><p>Execute the code using <a href=https://github.com/hamilton-lima/robolucha/blob/master/src/runner/src/com/robolucha/publisher/RemoteQueue.java>the RemoteQueue</a> instance as an <a href=https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html>AutoCloseable</a> so when the block finishes the close() the method from the object will be called releasing the <a href=https://github.com/xetorthio/jedis>Jedis</a> pools from memory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>assertEquals(&#34;subscribe&#34;, future.get(5, TimeUnit.SECONDS));
</span></span></code></pre></div><p>This assertion will wait for the future object (<a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html>CompletableFuture</a>) to be fulfilled or for the timeout of 5 seconds, whatever comes first. This is an elegant way to keep the unit test waiting for the pub and subprocess to end. Note that inside the accept method the future is fulfilled with the command future.complete(&ldquo;subscribe&rdquo;); See the complete test here:Â <a href=https://github.com/hamilton-lima/robolucha/blob/master/src/runner/src-test/com/robolucha/publisher/RemoteQueueTest.java>RemoteQueueTest</a></p><h2 id=complete-aka-last-words>.complete() a.k.a. last words</h2><p>There were lots of interesting challenges in this implementation, but for me, the most interesting one was the use of generics with Observables for the subscription process, It&rsquo;s nice to see fragments like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>public &lt;T&gt; BehaviorSubject subscribe(Class&lt;T&gt; clazzToSubscribe) {
</span></span><span class=line><span class=cl>BehaviorSubject&lt;T&gt; result = BehaviorSubject.create();
</span></span></code></pre></div><p>Of course, there are other ways to implement this without RxJava, or any other library, but it looks really good with the Observables.</p></div></div><div class=footer><div class=footer-social><span class="social-icon social-icon-twitter"><a href=https://twitter.com/athanazio title=twitter target=_blank rel=noopener><img src=/images/icons/twitter.svg width=24 height=24 alt=twitter></a></span>
<span class="social-icon social-icon-github"><a href=https://github.com/hamilton-lima title=github target=_blank rel=noopener><img src=/images/icons/github.svg width=24 height=24 alt=github></a></span>
<span class="social-icon social-icon-linkedin"><a href=https://www.linkedin.com/in/hamiltonlima title=linkedin target=_blank rel=noopener><img src=/images/icons/linkedin.svg width=24 height=24 alt=linkedin></a></span></div></div></div><script type=text/javascript src=/js/bundle.min.5993fcb11c07dea925a3fbd58c03c7f1857197c35fccce3aa963a12c0b3c9960.js></script></body></html>