<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>javascript on Hamilton Lima</title><link>https://hamiltonlima.com/tags/javascript/</link><description>Recent content in javascript on Hamilton Lima</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 28 Feb 2017 13:21:21 +0000</lastBuildDate><atom:link href="https://hamiltonlima.com/tags/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>From counters to promises a javascript journey</title><link>https://hamiltonlima.com/posts/from-counters-to-promises-a-javascript-journey/</link><pubDate>Tue, 28 Feb 2017 13:21:21 +0000</pubDate><guid>https://hamiltonlima.com/posts/from-counters-to-promises-a-javascript-journey/</guid><description>Beauty always promises, but never gives anything. Simone Weil
Unlike beauty, javascript promises are faithful, and will be fulfilled&amp;hellip; unless someone rejects it :) If you ever need to load images using javascript or did anything that needs to wait until something is done, you probably used a promise, maybe even without noticing. I see Promises as a nice way to simplify the callback hell, but don&amp;rsquo;t be fooled, the callbacks are still there, they are only organized in a more simpler way.</description></item><item><title>Vanhackton - Lessons Learned</title><link>https://hamiltonlima.com/posts/vanhackton-lessons-learned/</link><pubDate>Wed, 26 Oct 2016 23:00:17 +0000</pubDate><guid>https://hamiltonlima.com/posts/vanhackton-lessons-learned/</guid><description>After a very intense weekend I feel like coming from the battle :) But it feels very good to deliver a good result in such a small timeframe. On this post I will describe some lessons learned from the past weekend and some decisions I made that worth.
POC - the start For every project, I allways plan for proof of concepts, small implementations that isolate the implementation complexity by implementing just the necessary, to solve one problem.</description></item></channel></rss>